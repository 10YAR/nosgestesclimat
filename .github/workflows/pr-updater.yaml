name: Update PR comments

on:
  workflow_run:
    workflows: [ "VÃ©rification de la PR" ]
    types: [ completed ]
  #
  # pull_request:
  #   types: [ opened, synchronize ]
  # # This number should correspond to the IGNORE_RUNS_OLDER_THAN value below.
  # # When setting up for the first time, use "on: push" instead of "on: schedule"
  # # and set IGNORE_RUNS_OLDER_THAN to a very high number until it runs once.
  # push:
  #   branches:
  #     - '*'
  # # schedule:
  # #   - cron: '*/15 * * * *'

jobs:
  pr_comment:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2.3.4

      - name: Downloading Artifacts from Previous Workflow...
        uses: synergy-au/download-workflow-artifacts-action@v1
        with:
          # Only needed for private repos
          auth-token: ${{ secrets.GITHUB_TOKEN }}
          # You can get this from the workflow_run event. A workflow run ID is required.
          workflow-run-id: ${{ github.event.workflow_run.id }}

      - name: Reading the downloaded artifact
        run: |
          cat result.md

      - name: Running the script...
        uses: actions/github-script@v6
        with:
          # This snippet is public-domain, taken from
          # https://github.com/oprypin/nightly.link/blob/master/.github/workflows/pr-comment.yml
          script: |
            const {owner, repo} = context.repo;
            console.log('context: ', context);
            const run_id = context.payload.workflow_run.id;
            console.log('workflow_run.id:', run_id);
            const pull_requests = await github.rest.pulls.list(context.repo);
            console.log('Found ' + pull_requests.data.length + ' PRs...');
            if (!pull_requests.data.length) {
              return core.error("This workflow doesn't match any pull requests!");
            }
            const artifacts = await github.paginate(
              github.rest.actions.listWorkflowRunArtifacts, {owner, repo, run_id});
            console.log('Artifacts: ', artifacts);
            if (!artifacts.length) {
              return core.error('No artifacts found');
            }

            const fs = require('fs');

            var body = fs.readFile('result.md', 'utf8', (err, data) => {
              if (err) {
                console.error(err);
                exit(-1);
              }
              return data;
            });
            core.info("Review thread message body:", data);
            // TODO: find the corresponding PR (context.payload.head_sha == pr.head.sha)
            var triggered_pr;
            for (const pr of pull_requests.data) {
              console.log('pr.head.sha:', pr.head.sha);
              console.log('context.payload.workflow_run.head_sha', context.payload.workflow_run.head_sha);
              if (pr.head.sha == context.payload.workflow_run.head_sha) {
                triggered_pr = pr;
              }
            }
            console.log('triggered_pr:', triggered_pr);
            const issue_number = triggered_pr.number;
            const comments = await github.rest.issues.listComments({owner, repo, issue_number});
            console.log('comments:', comments);
            //const marker = 'yarn-compile-result';
            //body = '<!-- bot: ' + yarn-compile-result + ' -->\n' + body;
            //const existing = comments.filter((c) => c.body.includes(marker));
            //if (existing.length > 0) {
            //  const last = existing[existing.length - 1];
            //  core.info('Updating comment' + last.id);
            //  await github.rest.issues.updateComment({
            //    owner, repo,
            //    body,
            //    comment_id: last.id,
            //  });
            //} else {
            //  core.info('Creating a comment in issue / PR #' + issue_number);
            //  await github.rest.issues.createComment({issue_number, body, owner, repo});
            //}
